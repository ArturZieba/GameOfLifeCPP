#include <algorithm> //For std::generate()
#include <array> //For std::array<>
//#include <cstdlib> //For std::rand() - theoretically not needed, iostream > istream > ostream > ios > xlocnum already includes cstdlib, but it's still good practice to state includes explicitly
#include <iostream> //For std::cout
#include <random> //Contains superior randomization functions to rand() and srand() in <cstdlib>
#include <Windows.h> //For system("cls") and sleep() on Command Prompt;

//Game Of Life grid dimensions - static so that it is accessible without GOL instance, const beacuse the std::array size is not dynamic 
const int GRID_SIZE_X = 20;
const int GRID_SIZE_Y = 32;

//Forward declaration of the function so that it can be used in int main(), but defined elsewhere
bool CheckNeighbours(std::array<std::array<int, GRID_SIZE_Y>, GRID_SIZE_X>& grid, int x, int y);

int main()
{
	std::default_random_engine Generator; //Random number generator
	std::bernoulli_distribution Distribution; //Bernoulli distribution for bool - there should be around 50:50 true:false distribution without (double) stated in the declaration

	//Game Of Life grid arrays - using std::array<> instead of int[][] because of added functionality
	std::array<std::array<int, GRID_SIZE_Y>, GRID_SIZE_X> gridPrinted{}; //Grid that is printed to the Console
	std::array<std::array<int, GRID_SIZE_Y>, GRID_SIZE_X> gridCalculated{}; //"Buffer" grid that is used for calculating cells states

	//Range-based for loop to randomly populate the GridPrinted array; auto& to deduce the element type instead of typing template in and & because there is no need for more copies of this array, just the modification of it
	for (auto& Element : gridPrinted)
	{
		//std::generate fills a container in a specified range (.begin/.end - iterators pointing to first/past-the-end elements) with values generated by the specified generator function object - used lambda expression here
		//Lambda contains has & in its definition so that Generator/Distribution are in its capture list
		//Distribution(Generator) Generates a random boolean based on the randomly generated number with a set distribution (should be 50:50)
		std::generate(Element.begin(), Element.end(), [&]() { return Distribution(Generator) ? 1 : 0; });
	}

	//Game Of Life loop
	while (true) {
		//Apply CheckNeighbours to all of the gridPrinted array's elements and pass them to gridCalculated array
		for (int i = 0; i < GRID_SIZE_X; ++i)
		{
			for (int j = 0; j < GRID_SIZE_Y; ++j)
			{
				gridCalculated[i][j] = CheckNeighbours(gridPrinted, i, j) ? 1 : 0;
			}
		}

		gridPrinted.swap(gridCalculated); //Write the calculated cells update (gridCalculated) into the array that should be printed to the Console (gridPrinted)

		//Go through all of the array to be printed elements, if they are 1 print O and if they are 0 print space
		for (int i = 0; i < GRID_SIZE_X; ++i)
		{
			for (int j = 0; j < GRID_SIZE_Y; ++j)
			{
				std::cout << (gridPrinted[i][j] == 1 ? 'O' : ' '); //Parentheses because << has precedence over ? operand
			}
			std::cout << std::endl; //Separate rows
		}

		//"Animation" setup
		Sleep(500); //Wait x milliseconds
		system("cls"); //Clear Console
	}
}

//Check how many of the cell's neighbouring cells are alive and apply Game Of Life's rules to it then return whether the cell should be alive or dead
bool CheckNeighbours(std::array<std::array<int, GRID_SIZE_Y>, GRID_SIZE_X>& grid, int x, int y)
{
	int AliveNeighbours = 0; //Count how many cells around are alive

	for (int i = -1; i <= 1; i++)
	{
		for (int j = -1; j <= 1; j++)
		{
			if (!((i == 0) && (j == 0)))
			{
				if (x + i >= 0 && x + i < GRID_SIZE_X && y + j >= 0 && y + j < GRID_SIZE_Y && grid[x + i][y + j] == 1) //Make sure the array does not go out of bounds and the cell is alive (equal to 1)
				{
					++AliveNeighbours;
				}
			}
		}
	}

	//Game Of Life rules
	if (grid[x][y] == 1 && (AliveNeighbours < 2 || AliveNeighbours > 3)) return false; //Any live cell with fewer than two live neighbors dies, as if by underpopulation. + Any live cell with more than three live neighbors dies, as if by overpopulation.
	if (grid[x][y] == 1 && (AliveNeighbours == 2 || AliveNeighbours == 3)) return true; //Any live cell with two or three live neighbors lives on to the next generation.
	if (grid[x][y] == 0 && AliveNeighbours == 3) return true; //Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

	return false;
}
